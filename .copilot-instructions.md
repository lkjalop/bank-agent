# GitHub Copilot Instructions for Bank Account Agent

## Project Overview
This is a FastAPI-based bank account agent that provides REST API endpoints for basic banking operations. The application is designed to be deployed on Render's free tier.

## Technology Stack
- **Framework**: FastAPI (Python web framework)
- **Server**: Uvicorn (ASGI server)
- **Language**: Python 3.8+
- **Deployment**: Render (free tier)
- **Data**: Mock/in-memory data (no database)

## Project Structure
```
bank-account-agent/
├── main.py              # Main FastAPI application
├── requirements.txt     # Python dependencies
├── render.yaml         # Render deployment configuration
├── README.md           # Project documentation
└── .gitignore          # Git ignore file
```

## Code Style Guidelines

### Python/FastAPI Conventions
- Use type hints for all function parameters and return types
- Follow PEP 8 naming conventions (snake_case for functions/variables)
- Use docstrings for all API endpoints
- Keep functions focused and single-purpose
- Use meaningful variable names

### API Design Patterns
- Use RESTful URL patterns: `/account/balance`, `/account/info`, `/account/transactions`
- Return consistent JSON response structures
- Include proper HTTP status codes
- Use appropriate HTTP methods (GET, POST, PUT, DELETE)
- Include timestamps in ISO format for all responses

### Error Handling
- Use FastAPI's HTTPException for error responses
- Include descriptive error messages
- Return appropriate HTTP status codes (400, 401, 404, 500)
- Log errors for debugging

## Current API Endpoints

### Existing Endpoints
1. `GET /` - Health check endpoint
2. `GET /account/balance` - Get account balance
3. `GET /account/info` - Get account information
4. `GET /account/transactions` - Get recent transactions

### Response Format Standards
- Always include timestamps in ISO format
- Mask sensitive data (account numbers show only last 4 digits)
- Use consistent currency formatting: `$1,234.56`
- Include account number reference in all account-related responses

## Security Considerations

### Data Protection
- Never expose full account numbers (mask all but last 4 digits)
- Don't include sensitive authentication tokens in responses
- Validate all input parameters
- Use HTTPS in production (handled by Render)

### Mock Data Guidelines
- Keep mock data realistic but obviously fake
- Use consistent data types across all endpoints
- Include realistic transaction descriptions and amounts
- Maintain data consistency across related endpoints

## Development Guidelines

### When Adding New Endpoints
1. Follow RESTful conventions
2. Add proper type hints
3. Include comprehensive docstrings
4. Add input validation using Pydantic models
5. Return consistent response formats
6. Include appropriate error handling

### Database Integration (Future)
- When transitioning from mock data to real database:
  - Use SQLAlchemy ORM
  - Create proper database models
  - Implement connection pooling
  - Add database migrations
  - Use environment variables for connection strings

### Testing Suggestions
- Add unit tests for all endpoints
- Test both success and error cases
- Mock external dependencies
- Test input validation
- Verify response formats

## Deployment Considerations

### Render-Specific
- Use environment variables for configuration
- Keep resource usage minimal (512 MB RAM limit)
- Handle cold starts gracefully
- Log appropriately for debugging

### Environment Variables
- `PORT`: Server port (provided by Render)
- `DATABASE_URL`: Database connection (when implemented)
- `SECRET_KEY`: For JWT tokens (when authentication added)

## Common Code Patterns

### Response Model Example
```python
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class AccountResponse(BaseModel):
    account_holder: str
    account_number: str
    balance: str
    currency: str
    last_updated: str
```

### Error Response Example
```python
from fastapi import HTTPException, status

def get_account_by_id(account_id: str):
    if not account_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Account ID is required"
        )
```

### Input Validation Example
```python
from pydantic import BaseModel, validator

class TransactionRequest(BaseModel):
    amount: float
    description: str
    
    @validator('amount')
    def amount_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Amount must be positive')
        return v
```

## Future Enhancement Ideas

### Authentication
- Implement JWT token-based authentication
- Add user registration and login endpoints
- Protect sensitive endpoints with authentication middleware

### Advanced Features
- Add transaction history pagination
- Implement account transfer functionality
- Add transaction categorization
- Include account statements generation

### Data Persistence
- Integrate with PostgreSQL or MongoDB
- Add database migrations
- Implement proper data models
- Add data validation and constraints

## Debugging Tips
- Use `print()` statements for quick debugging (remove before production)
- Enable FastAPI debug mode during development
- Check Render logs for deployment issues
- Use the interactive docs at `/docs` for testing endpoints

## Performance Considerations
- Keep response times under 200ms for simple operations
- Implement pagination for large data sets
- Use async/await for I/O operations
- Cache frequently accessed data when appropriate

Remember: This is a demo application with mock data. In production, implement proper authentication, use a real database, and add comprehensive error handling and logging.
